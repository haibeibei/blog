[{"title":"四驱兄弟","date":"2017-04-01T03:30:17.000Z","path":"2017/04/01/四驱兄弟/","text":"四驱兄弟90后的童年基本上是随着一大批日本动漫成长的。当时还不叫动漫，叫动画片。四驱兄弟当时着实火了一把。顺带的周边产品也是卖的火爆。记得当时小学时候，5块钱一辆超星模王，巨无霸，魔鬼司令，先驱音速，一辆接着一辆买。组装好之后直接在院子里野跑。极其容易撞墙然后整个车子废了，摔得稀烂。但是仍旧是乐此不疲的一辆接着一辆野跑，再坏掉，再组装，一遍一遍的重复。后来还慢慢学着改装四驱车。美洲豹马达，魔鬼轮毂，铝合金龙头凤尾。一套下来要好几十甚至上百，对于当时的零花钱来说，着实是一笔大的花销。 今天偶然间又看到了四驱车。不过已经不是小时候的超星模王，奥迪双钻了。而是真正的正牌四驱车，tamiya，田宫双星。又一次的勾起了沉寂已久的对四驱车的喜爱。从YouTube上开始看有关的比赛，改装，等等一系列的视频。感觉小时候那股好奇心又被激发了，从淘宝上去买一辆几十块的四驱车，再配上碳纤维配件，轴承导轮，海绵刹车，一套下来，几百大洋出去。东西到手，已经变得生疏了。组装一辆车子下来花了3小时，但是看着工艺品一般的四驱车，心里还是一阵阵的暗喜。做喜欢的事儿，不论多久，多难，都是内心满足的。","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"https://haibeibei.github.io/blog/tags/随笔/"},{"name":"四驱车","slug":"四驱车","permalink":"https://haibeibei.github.io/blog/tags/四驱车/"}]},{"title":"express web开发常用代码","date":"2017-03-08T16:00:17.000Z","path":"2017/03/09/express web开发常用代码/","text":"处理普通post请求12345678const bodyParser = require('body-parser');// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123;extended: false&#125;));// parse application/jsonapp.use(bodyParser.json());app.post('/',(req,res)=&gt;&#123; console.log(req.body);&#125;) 处理session1234567891011121314151617const session = require('express-session');app.use(session(&#123; secret: 'keyboard cat', resave: false, saveUninitialized: true&#125;));app.get('/logincheck',(req,res)=&gt;&#123; req.session.login = true;&#125;)// 中间件app.use('/admin',(req,res,next)=&gt;&#123; if(req.seesion.login)&#123; next(); &#125;else&#123; res.redirct('/login'); &#125;&#125;) 上传文件12345678910111213141516171819const fs = require('fs');const async = require('async');const multer = require('multer');const upload = multer(&#123;dest: 'uploads/'&#125;);app.post('/upload', upload.single('wangEditorH5File'), function (req, res) &#123; async.series([ function (callback) &#123; fs.createReadStream(req.file.path).pipe(fs.createWriteStream('public/imgs/' + req.file.originalname)); callback(null); &#125;, function (callback) &#123; fs.unlink(path.resolve(req.file.path)); callback(null); &#125; ], function () &#123; res.end('/imgs/' + req.file.originalname); &#125;);&#125;); react富文本编辑器组件12345678910111213&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/wangEditor.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;page&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery-2.2.1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/wangEditor.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/admin.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930const React = require(&apos;react&apos;);const ReactDOM = require(&apos;react-dom&apos;);class Editor extends React.Component &#123; constructor(props) &#123; super(props); this.getContents = this.getContents.bind(this); &#125; componentDidMount() &#123; this.editor = new window.wangEditor(this.el); this.editor.config.uploadImgUrl = &apos;/upload&apos;; this.editor.create(); // 初始化内容 this.editor.$txt.html(&apos;&lt;div&gt;this is a a&lt;/div&gt;&apos;); &#125; getContents() &#123; console.log(this.editor.$txt.html()); &#125; render() &#123; return ( &lt;div&gt; &lt;div contentEditable=&quot;true&quot; style= ref=&#123;(el)=&gt;&#123;this.el = el&#125;&#125;&gt;&lt;/div&gt; &lt;div onClick=&#123;this.getContents&#125;&gt;获取内容&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Editor/&gt;, document.querySelector(&apos;#page&apos;)); 创建md51234const crypto = require(&apos;crypto&apos;);const hash = crypto.createHash(&apos;md5&apos;);hash.update(&apos;123456&apos;);console.log(hash.digest(&apos;hex&apos;)); mysql封装12345678910111213141516171819const mysql = require(&apos;mysql&apos;);const pool = mysql.createPool(&#123; connectionLimit: 1000, host: &apos;localhost&apos;, user: &apos;root&apos;, password: &apos;root&apos;, database: &apos;music&apos;&#125;);function query(sql, arr, fn) &#123; pool.getConnection((err, con)=&gt; &#123; con.query(sql, arr, (err, res)=&gt; &#123; con.release(); fn(err, res); &#125;) &#125;)&#125;module.exports = &#123; query: query&#125;; 防止意外退出123process.on(&apos;uncaughtException&apos;, (ex)=&gt; &#123; console.log(&apos;error&apos;);&#125;); react项目中使用fetch123456789101112131415161718192021// npm install whatwg-fetch --save// 在html页面中引入whatwg-fetch.js// fetch上传文件var input = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;)var data = new FormData()data.append(&apos;file&apos;, input.files[0])data.append(&apos;user&apos;, &apos;hubot&apos;)fetch(&apos;/avatars&apos;, &#123; method: &apos;POST&apos;, body: data&#125;)// fetch提交表单var form = document.querySelector(&apos;form&apos;)fetch(&apos;/users&apos;, &#123; method: &apos;POST&apos;, body: new FormData(form)&#125;) 转载自马彦龙的博客.","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"express","slug":"express","permalink":"https://haibeibei.github.io/blog/tags/express/"}]},{"title":"创建ajax的过程","date":"2016-09-08T02:40:15.000Z","path":"2016/09/08/创建ajax的过程/","text":"#Ajax全称是Asynchronous JavaScript and XML ，其中Asynchronous是异步的意思，它又别于传统的Web开发采用的同步的方式。 Ajax并非一种新的技术，而是几种原有的技术的结合体，它由下列技术组合而成。12345671使用CSS和XHTML来表示2使用DOM模型来交互和动态显示3使用XHTMLHttpResquest来和服务器进行异步通信。4使用JavaScript来绑定和调用 创建过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. //(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. //(3)设置响应HTTP请求状态变化的函数. //(4)发送HTTP请求. //(5)获取异步调用返回的数据. //(6)使用JavaScript和DOM实现局部刷新.var xmlHttp = new XMLHttpRequest(); xmlHttp.open(&apos;GET&apos;,&apos;demo.php&apos;,&apos;true&apos;); xmlHttp.send() xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200)&#123; &#125; &#125; //(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. //(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. //(3)设置响应HTTP请求状态变化的函数. //(4)发送HTTP请求. //(5)获取异步调用返回的数据. //(6)使用JavaScript和DOM实现局部刷新. var xmlHttp = new XMLHttpRequest(); xmlHttp.open(&apos;GET&apos;,&apos;demo.php&apos;,&apos;true&apos;); xmlHttp.send() xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200)&#123; &#125; &#125; 为什么要使用ajax框架 简化JavaScript的开发难度 解决浏览器兼容性问题 简化开发流程 增强用户体验，提高系统性能","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"ajax","slug":"ajax","permalink":"https://haibeibei.github.io/blog/tags/ajax/"}]},{"title":"http状态码","date":"2016-06-15T10:30:17.000Z","path":"2016/06/15/http状态码/","text":"错误代码(也称作状态代码)，指为服务器所接收每个请求(网页点击)分配的 3 位数代码。多数有效网页点击都有状态代码 200(“正常”)。”网页未找到”错误会生产 404 错误。某些常见的代码以粗体显示。 1xx(临时响应) 用于表示临时响应并需要请求者执行操作才能继续的状态代码。 代码说明 100(继续) 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。 101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。 2xx(成功) 用于表示服务器已成功处理了请求的状态代码。 代码 说明 200(成功) 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt文件显示为此状态，那么，这表示 Googlebot 已成功检索到该文件。 201(已创建) 请求成功且服务器已创建了新的资源。 202(已接受) 服务器已接受了请求，但尚未对其进行处理。 203(非授权信息) 服务器已成功处理了请求，但返回了可能来自另一来源的信息。 204(无内容) 服务器成功处理了请求，但未返回任何内容。 205(重置内容) 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如清除表单内容以输入新内容)。 206(部分内容) 服务器成功处理了部分 GET 请求。 3xx(已重定向) 要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 Googlebot 由于重定向错误而无法抓取的网址。 代码说明 300(多种选择) 服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。 301(永久移动) 请求的网页已被永久移动到新位置。服务器返回此响应(作为对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。 302(临时移动) 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。 303(查看其他位置) 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 304(未修改) 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。 305(使用代理) 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 307(临时重定向) 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。 4xx(请求错误) 这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。 代码说明 400(错误请求) 服务器不理解请求的语法。 401(未授权) 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。 403(已禁止) 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码(您可在 Google 网站管理员工具中诊断下的网络抓取页面上看到此状态代码)，那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。 404(未找到) 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。 如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。(该文件应当位于顶级域名上，且应当名为 robots.txt)。 如果您在 Googlebot 尝试抓取的网址上发现此状态(位于”诊断”标签的 HTTP 错误页上)，那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接(旧链接或输入有误的链接)。 405(方法禁用) 禁用请求中所指定的方法。 406(不接受) 无法使用请求的内容特性来响应请求的网页。 407(需要代理授权) 此状态代码与 401(未授权)类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 408(请求超时) 服务器等候请求时超时。 409(冲突) 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。 410(已删除) 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404(未找到)代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。 411(需要有效长度) 服务器不会接受包含无效内容长度标头字段的请求。 412(未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413(请求实体过大) 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。 414(请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法进行处理。 415(不支持的媒体类型) 请求的格式不受请求页面的支持。 416(请求范围不符合要求) 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。 417(未满足期望值) 服务器未满足”期望”请求标头字段的要求。 5xx(服务器错误) 这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明 500(服务器内部错误) 服务器遇到错误，无法完成请求。 501(尚未实施) 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。 502(错误网关) 服务器作为网关或代理，从上游服务器收到了无效的响应。 503(服务不可用) 目前无法使用服务器(由于超载或进行停机维护)。通常，这只是一种暂时的状态。 504(网关超时) 服务器作为网关或代理，未及时从上游服务器接收请求。 505(HTTP 版本不受支持) 服务器不支持请求中所使用的 HTTP 协议版本。","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"状态码","slug":"状态码","permalink":"https://haibeibei.github.io/blog/tags/状态码/"}]},{"title":"搭建前端自动化开发环境","date":"2016-05-02T12:40:17.000Z","path":"2016/05/02/搭建前端自动化搭建环境/","text":"搭建前端自动化开发环境May 23, 2016 随着node.js的迅猛发展,前端开发已经脱离了刀耕火种,进入蒸汽机时代。 这里介绍一些基于node.js的前端自动化开发工具: node.js &amp;&amp; npm Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 最简单的理解： node.js又提供了一个javascript的运行环境,以前,javascript代码可以在浏览器中运行,现在,它可以在node.js所搭建的运行环境中运行了. 浏览器并不是一个理想的代码运行环境,浏览器在给javascript扩展API的时候,基于安全的考虑,很多功能都不能做.比如操作文件,随意的处理网络请求.所以,在以前,javascript相对于python,ruby 是一门不完善的语言. 在node.js这个运行环境中,并没有这样那样的限制,在这里,javascript成功变成了python,ruby,变成了一门真正的语言. windows下 node.js 的安装很简单,访问node.js官网,下载安装包,默认安装就好. 打开控制台测试是否安装成功 1node -v npm 是node.js的包管理工具, node.js以模块的方式组织代码,允许任何人提交一个模块,来扩展javascript, npm用来管理这些模块 12npm -vnpm install -g bower 如果有的包安装不上 复制以下代码替换 x 为安装不上的包 (会带来一定的问题,建议翻墙) 1npm install x --registry=http://registry.npm.taobao.org bowernpm install -g bower 包管理工具,把项目中所依赖的文件保存在bower.json中，只需分享给别人bower.json即可 bower install 寻找bower.json文件 把依赖项全部安装 bower install 在bower官网注册的库 --save 安装一个库，把库作为依赖项写入bower.json bower install 网址 --save bower install github短语 --save bower 依赖git 把git命令添加到环境变量的方法: 在c盘中搜索 git.exe 找到它所处的位置,添加到环境变量 grunt &amp;&amp; gulpnpm install -g gulp 一个典型的gulp配置文件; yeomonnpm install -g yo npm install -g generator-webapp yo webapp 脚手架，一键自动生成一个配置好的项目，包括目录结构，项目依赖，开发依赖 一般和bower gulp 结合 自定义一个yeoman 包 详细步骤见: 创建一个脚手架 大致如下 12npm install -g generator-generatoryo generator 会生成一个目录结构 123456--generators/----app/------temlates/ 此目录中放静态文件,以供拷贝------index.js 默认会运行的文件其他省略 编写index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&apos;use strict&apos;;var path = require(&apos;path&apos;);var yeoman = require(&apos;yeoman-generator&apos;);var chalk = require(&apos;chalk&apos;);var yosay = require(&apos;yosay&apos;);var wiredep = require(&apos;wiredep&apos;);var mkdirp = require(&apos;mkdirp&apos;);var _s = require(&apos;underscore.string&apos;);module.exports = yeoman.Base.extend(&#123; prompting: function () &#123; // Have Yeoman greet the user. this.log(yosay( &apos;Welcome to the remarkable &apos; + chalk.red(&apos;generator-mobile-app-myl&apos;) + &apos; generator!&apos; )); var prompts = [ &#123; type: &apos;confirm&apos;, name: &apos;includeBootStrap&apos;, message: &apos;Would you like to use bootStrap?&apos;, default: true &#125;, &#123; type: &apos;confirm&apos;, name: &apos;includeJquery&apos;, message: &apos;Would you like to use jQuery?&apos;, default: true &#125;, &#123; type: &apos;confirm&apos;, name: &apos;includeTouch&apos;, message: &apos;Would you like to use Baidu Touch.js?&apos;, default: true &#125;, &#123; type: &apos;confirm&apos;, name: &apos;includeSwiper&apos;, message: &apos;Would you like to use Swiper.js?&apos;, default: true &#125;, &#123; type: &apos;input&apos;, name:&apos;name&apos;, message :&apos;you app name?&apos;, default:&apos;mobile&apos; &#125; ]; return this.prompt(prompts).then(function (props) &#123; this.props = props; &#125;.bind(this)); &#125;, default: function()&#123; if (path.basename(this.destinationPath()) !== this.props.name) &#123; this.log( &apos;Your generator must be inside a folder named &apos; + this.props.name + &apos;\\n&apos; + &apos;I\\&apos;ll automatically create this folder.&apos; ); mkdirp(this.props.name); this.destinationRoot(this.destinationPath(this.props.name)); &#125; &#125;, writing: function () &#123; var packageJson = &#123; &quot;private&quot;: true, &quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.0&quot;, &#125; &#125;; this.fs.writeJSON(&apos;package.json&apos;,packageJson); var bowerJson = &#123; name: this.appname, private: true, main: &apos;index.html&apos;, dependencies: &#123;&#125; &#125;; if(this.props.includeJquery)&#123; bowerJson.dependencies[&apos;jquery&apos;] = &apos;~2.1.1&apos;; &#125; if(this.props.includeBootStrap)&#123; bowerJson.dependencies[&apos;bootstrap&apos;] = &apos;^3.3.6&apos;; &#125; if(this.props.includeTouch)&#123; bowerJson.dependencies[&apos;touch.code.baidu.com&apos;] = &apos;Clouda-team/touch.code.baidu.com&apos;; &#125; if(this.props.includeSwiper)&#123; bowerJson.dependencies[&apos;Swiper&apos;] = &apos;swiper#^3.3.1&apos;; &#125; this.fs.writeJSON(&apos;bower.json&apos;,bowerJson); this.fs.copy( this.templatePath(&apos;main.js&apos;), this.destinationPath(&apos;scripts/main.js&apos;) ); this.fs.copy( this.templatePath(&apos;gitignore&apos;), this.destinationPath(&apos;.gitignore&apos;) ); this.fs.copy( this.templatePath(&apos;main.scss&apos;), this.destinationPath(&apos;styles/main.scss&apos;) ); this.fs.copy( this.templatePath(&apos;index.html&apos;), this.destinationPath(&apos;index.html&apos;) ); this.fs.copy( this.templatePath(&apos;touch/&apos;), this.destinationPath(&apos;images/touch/&apos;) ); &#125;, install: function()&#123; this.installDependencies(&#123; &#125;); &#125;, end:function()&#123; wiredep(&#123; src: &apos;index.html&apos; &#125;); &#125;&#125;); 然后 1npm link 随后就可以 your name 了","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"前端自动化","slug":"前端自动化","permalink":"https://haibeibei.github.io/blog/tags/前端自动化/"}]},{"title":"原型","date":"2016-03-01T05:30:17.000Z","path":"2016/03/01/JavaScript原型及原型链/","text":"一、原型原型是 ECMAScript 实现继承的过程中产生的一个概念。 继承： java 中：指在已有的一个类基础上创建新类的过程。 ES：指在一个对象的基础上创建新对象的过程。原型指在这过程中作为基础的对象。 创建原型12345678// 鸟对象var bird = &#123; name: &quot;bird&quot;, fly: function () &#123; console.log(&quot;fly&quot;); &#125;&#125; 假设我们需要一个鹰对象，因为我们已经有一个鸟对象，因此可以从这个鸟对象继承信息。123//鹰对象var eagle = Object.create(bird);eagle.fly(); // fly 通过 Object.create() 方法我们传入了鸟对象，作为鹰对象的原型来创建鹰对象，然后鹰对象中就产生了一个叫 proto 的指针，这指针指向鸟对象。通过这个指针鹰对象就可以访问到鸟对象的 fly() 方法，当然编译器帮我们自动处理了这个指针访问的过程。 但是对于原型来讲，prototype 属性是很重要的存在，下面来讲讲 prototype。 二、prototype 属性从一个例子讲 prototype 属性存在解决了什么问题。现在有一个叫做 DOG 的构造函数，表示狗对象的原型。123function DOG(name)&#123; this.name = name;&#125; 对这个构造函数使用new，就会生成一个狗对象的实例。12var dogA = new DOG(&apos;大毛&apos;);alert(dogA.name); // 大毛 new运算符的缺点但是，用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。 比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。1234function DOG(name)&#123; this.name = name; this.species = &apos;犬科&apos;;&#125; 然后，生成两个实例对象：12var dogA = new DOG(&apos;大毛&apos;);var dogB = new DOG(&apos;二毛&apos;); 这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。12dogA.species = &apos;猫科&apos;;alert(dogB.species); // 显示&quot;犬科&quot;，不受dogA的影响 每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。 prototype属性的引入考虑到这一点，Brendan Eich 决定为构造函数设置一个 prototype 属性。这个属性包含一个对象（以下简称” prototype 对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。 实例对象一旦创建，将自动引用 prototype 对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。 还是以 DOG 构造函数为例，现在用 prototype 属性进行改写：12345678910function DOG(name)&#123; this.name = name;&#125;DOG.prototype = &#123; species : &apos;犬科&apos; &#125;;var dogA = new DOG(&apos;大毛&apos;);var dogB = new DOG(&apos;二毛&apos;);alert(dogA.species); // 犬科alert(dogB.species); // 犬科 现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。1234DOG.prototype.species = &apos;猫科&apos;;alert(dogA.species); // 猫科alert(dogB.species); // 猫科 三、原型链讲原型一个不可避免的概念就是原型链，原型链是通过前面两种创建原型的方式 Object.create() 或 DOG.prototype 时生成的一个 proto 指针来实现的。 以 DOG 为例讲原型链 红色的箭头就是原型链。DOG 对象有一个 prototype 对象，而实例对象 dogA 通过一个 proto 对象引用这个 prototype 对象。 可以看出 dogA 能访问到的 species 属性实际上是在 DOG 的原型电源线 prototype 中，因此才能实现实例对象属性共享访问却不能修改。 但是在 DOG.prototype 中还存在一个 proto 属性，这又是指向谁呢？ 看图 指向 Object 对象，这样 DOG 对象就拥有 Object 对象中原型属性和方法。比如说 toString() 就在其中。 还有一点，那就是 Js 的函数也是对象啊，我们每个创建的函数其实也继承了一个函数对象，而函数则继承了 Object 对象。 以上就是一个简单的 Dog 类完整的原型链。 总结一下原型链作用：对象属性的访问修改和删除。 访问。优先在对象本身查找，没有则顺着原型链向上查找 修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。 四、总结由于所有的实例对象共享同一个 prototype 对象，那么从外界看起来，prototype 对象就好像是实例对象的原型，而实例对象则好像”继承”了 prototype 对象一样。","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"原型和原型链","slug":"原型和原型链","permalink":"https://haibeibei.github.io/blog/tags/原型和原型链/"}]},{"title":"express web开发常用代码","date":"2015-09-02T02:00:17.000Z","path":"2015/09/02/Fullpage配置项/","text":"Fullpage 插件配置项Apr 5, 2016 jQuery插件 插件调用 123456789101112131415&lt;ul id=&quot;lunbo&quot;&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jqeury.lunbo.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(&apos;#lunbo&apos;).lunbo(&#123; //一些配置项 time:40; step:function()&#123;&#125;&#125;);&lt;/script&gt; jQuery 插件文件 12345678(function($)&#123; var lunbo = function () &#123; console.log(1); &#125; $.fn.extend(&#123; lunbo:lunbo; &#125;)&#125;)(jQuery) cdn (content deliver network) 内容分发网络如果百度使用了 某个 cdn中的jquery.js,而且用户打开过百度, 我们自己同样使用了 同一个 cdn中的jquery.js, 用户打开我们的网页时使用浏览器缓存中的jquery.js. 例子 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt; &lt;script src=&quot;https://cdn.boot.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; fullpage 插件基本使用12345678910111213141516171819&lt;link rel=&quot;stylesheet&quot; href=&quot;jquery.fullPage.css&quot; media=&quot;screen&quot; title=&quot;no title&quot; charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jquery.fullPage.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123; $(&apos;#fullpage&apos;).fullpage(&#123; //这里是配置项 &#125;);&#125;)&lt;/script&gt;&lt;div id=&quot;fullpage&quot;&gt; &lt;div class=&quot;section&quot; id=&quot;section-1&quot;&gt; &lt;div class=&quot;slide&quot;&gt; &lt;/div&gt; &lt;div class=&quot;slide&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section&quot; id=&quot;section-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;section&quot; id=&quot;section-3&quot;&gt;&lt;/div&gt;&lt;/div&gt; 每滚动一屏，会给当前section加上 active class 所以我们可以写出类似下面这样的 scss 文件来操控动画 12345678910111213141516#section1&#123; h1&#123; /**/ &#125; h2&#123; transition: /**/ &#125;&#125;#section1.active&#123; h1&#123; animation:/**/ &#125; h2&#123; /**/ &#125;&#125; 插件配置项 sectionsColor 一个数组 规定了各个section的颜色 verticalCentered 每一页的内容是否垂直居中，默认值为true resize 字体大小是否随窗口缩放而缩放 默认值为false scrollingSpeed 滚动速度,默认为700毫秒 anchors 给每个section定义锚链接 lockAnchors 是否锁定锚链接 active class 默认显示哪个section easing 定义页面section滚动的动画方式 设置这个值需要引入jquery.easings 插件 css3 默认为true,使用css3 transform 来实现页面滚动动画 loopTop 滚动到最顶部后是否连续滚动到底部，默认值为false loopBottom 滚动到最底部后是否连续滚动回顶部 默认值为false loopHorizontal 横向slide幻灯片是否循环滚动，默认值为true autoScrolling 是否使用插件的滚动方式，默认值为true, 如果设置为false,则会出现浏览器自带的滚动条 scrollBar 是否包含滚动条，默认值为false 如果设置为true,则浏览器自带的滚动条出现 页面滚动时还是页滚动，但是滚动条的默认行为也效果 paddingTop paddingBottom 设置每一个section顶部和底部的padding，默认值为0 如果我们需要设置一个固定在顶部或者底部的菜单，导航，元素等，可以使用这两个配置项 fixedElements 普通方式书写的固定定位元素会被插件覆盖 需要我们通过指定这个属性才会生效，参数为一个jquery选择器 keyboardScrolling 是否可以使用键盘方向键导航，默认值为true touchSensitivity 在移动设备中滑动页面的敏感性，默认为5，按百分比衡量，越大则越难滑动 continuousVertical 是否循环滚动，默认值为false，如果设置为true,则页面会循环滚动， 不像loopTop loopBottom那样出现跳动 这个属性和loopTop loopBottom 不兼容 不要同时设置 animateAnchor 锚链接是否可以控制滚动动画，默认为true。如果设置为false,则通过锚链接定位到某个页面显示不再有动画 recordHistory 是否记录历史,默认为true,可以记录页面滚动的地址 通过浏览器前进和后退按钮来导航 menu 绑定菜单，设定的相关属性与anchors的值对应后，菜单可以控制滚动，默认值为 false 可以设置为菜单的jquery选择器 1234&lt;ul id=&quot;fullpageMenu&quot;&gt; &lt;li data-menuanchor=&quot;page1&quot;&gt;&lt;a href=&quot;#page1&quot;&gt;1&lt;/a&lt;/li&gt; .....&lt;/ul&gt; navigation 是否显示导航，默认false 如果设置为true 会显示小圆点，作为导航 navigationPosition 导航小圆点位置，可以设置为left或者right navigationTooltips 导航小圆点的tooltips设置，默认为[],按照顺序放置 showActiveTooltip 是否显示当前页面的导航的tooltip信息，默认为false slidesNavigation 是否显示横向幻灯片的导航，默认值为false slidesNavPosition 横向幻灯片导航的位置，默认为bottom 可以设置为top controlArrows 定义是否通过箭头来控制slide幻灯片,默认值为true 在移动设备上可以通过滑动来操作幻灯片 scrollOverflow 内容超过满屏后是否显示滚动条，默认为false. 如果设置为true,则会显示滚动条 如果要滚动查看内容，还需要jquery.slimscroll插件，该插件主要用于模拟传统的浏览器滚动条 sectionSelector section的选择器，默认为.section slideSelector slide的选择器 默认为.slide. 配置项中的回调函数 afterLoad(anchorLink,index) 滚动到某一section，且滚动结束后，会触发一次此回调函数，函数接收 anchorLink 和index 两个参数， anchorLink 是锚链接的名称 index 是序号 从1开始计算 可以根据 anchorLink 和 index的参数值判断触发相应的事件 onLeave(index,nextIndex,direction) 离开一个section时触发，通过return false可以取消滚动 离开的序号 到达的序号 滚动的方向 afterRender() 页面结构生成之后的回调函数 afterResize() 浏览器窗口尺寸改变之后的回调函数 afterSlideLoad() 滚动到某一个幻灯片后的回调函数 onSlideLeave 离开一个slide之后的回调函数 $.fn.fullpage 对象中的方法介绍 moveSectionUp() moveSectionDown() 123$(&apos;#movedown&apos;).on(&apos;click&apos;,function()&#123; $.fn.fullpage.moveSectionDown();&#125;) moveTo(section,slide) 滚动到第几页，第几个幻灯片，注意，页面从1开始，而幻灯片从0开始 silentMoveTo(section,slide) 滚动到第几页，和moveTo一样，但是没有动画效果 moveSlideRight() 幻灯片向右滚动 moveSlideLeft() 幻灯片向左滚动 setAutoScrolling() setLockAnchors() setRecordHistory() setScrollingSpeed() setAllowScrolling(boolean,[directions]) 添加或删除鼠标滚轮/滑动控制，第一个参数true为启用，false 为禁用 后面的参数为方向，取值包含 all,up,down,left,right,可以使用多个，逗号隔开 destory(type) 销毁fullpage特效，type可以不写，或者使用all,不写type,fullpage给页面添加的样式和html元素还在 如果使用all,则样式 html等全部销毁 reBuild() 重新更新页面和尺寸，用于通过ajax请求后改变了页面结构之后，重建效果","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"Fullpage","slug":"Fullpage","permalink":"https://haibeibei.github.io/blog/tags/Fullpage/"}]},{"title":"JavaScript之闭包","date":"2015-08-12T13:30:17.000Z","path":"2015/08/12/JavaScript之闭包/","text":"闭包闭包（closure）是Javascript语言的一个重点，也是难点。 百度版本闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义局部变量。 简述闭包，简单来说就是可以读取其他函数内部变量的函数。只要满足这一点的函数，都可以叫闭包。 作用域主要分为两种：全局变量和局部变量。 全局变量？局部变量？ 局部变量:只能用于定义它函数内部。对于其他的函数或脚本代码是不可用的。 123456789function myFunction() &#123; var n = 5; return n * n; &#125; myFunction();// 25 换个方式 function myFunction() &#123; var n = 5; return n * n;&#125; console.log(n);//Uncaught ReferenceError: n is not defined 全局变量：函数可以访问由函数内部定义的变量。123456789101112131415var n = 5; function myFunction() &#123; return n * n; &#125; myFunction();// 25``` ### Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。例如： ```var n=1;function example()&#123; alert(n); &#125; f1(); // 1 另一方面，在函数外部自然无法读取函数内的局部变量。例如：12345function example()&#123; var n=1;&#125;alert(n); // error 报错 函数内部声明变量的时候，必须使用var命令去声明一个变量。如果不用的话，就会声明了一个全局变量。例如：12345function example()&#123;n=1;&#125;example();alert(n); // 1 夹不到菜，怎么让大人帮忙？就好比小孩在饭桌上吃饭，由于手比较短，只能在自己力所能及的范围内夹菜，也就是夹自己面前的菜（执行环境）；但是我们可以借用闭包（大人帮忙）的方式来夹别的菜。当我们需要得到函数内的局部变量时，正常情况下，是取不到的，只有通过巧妙的方法去实现。 解决方法：就是在自己的函数内部在定义一个函数E，然后再将函数E的值 return 回去，不就可以被访问了。\\ 废话少说，上菜！！！123456789function example()&#123; var n=1; function example2()&#123; alert(n); &#125; return example2;&#125;var result=example();result(); // 1 好像有点明白了，但是怎么用呢？闭包不仅可以读取函数内部的变量，上面也提到了，还能让这些变量的值始终保持在内存中。我们再来看下面这个例子1234567891011121314function example1()&#123; var n=1; Add = function() &#123; n+=1 &#125; function example2()&#123; alert(n); &#125; return example2; &#125; var result=example1(); result(); // 1 Add(); result(); // 2 上面的代码中第一个” result(); “执行完以后，输出结果 “1”,第二的” result(); “执行完以后，输出结果 “2”，这就证明了，函数 example1 中的局部变量n一直保存在内存中，并没有在第一个” result(); “执行完以后被自动清除；才能在执行第二个”result(); “完以后，输出结果 “2”，如果这样就容易造成我们平时所说的全局空间污染。还需要注意的是，上面的 “Add=function(){n+=1}” 这部分代码，一看这家伙居然没有名字（匿名函数），而且，变量还是没通过 var 去命名的，所以呢，就定义成了一个全局变量，所以外部函数当然可以对它”拳打脚踢”的操作咯；所以就有了”Add();” 执行以后，第二个 “result();”才能实现 n 的累加输出 “2”。 使用闭包需要注意些什么由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE浏览器中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 回收内存方法1234567function example() &#123; var n = 1; return fun()&#123; alert(n++) &#125;; &#125; fun();// 1 执行完后 n++，变量n任然存在于内存中 fun = null;// n被回收 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 嵌套函数的闭包12345678function example() &#123; var n = 1; return fun()&#123; alert(n++) &#125;;&#125; var fun = example(); fun();// 1 执行完后 n++，变量n任然存在于内存中 fun();// 2 fun = null;// n被回收 闭包的缺点就是常驻内存，闭包会使变量始终保存在内存中，如果使用不当会增大内存使用量，很容易造成内存泄露。 正常情况下外部函数是不能访问内部函数的变量的，但是可以利用闭包来实现对函数内部变量的访问。 一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！ 简而言之，闭包就是内部函数和外部函数连接的一座桥梁，（大人就是小孩与饭桌上所有菜的小助手）。 转载自FSUX.ME作者: FSUX","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"javascript","slug":"javascript","permalink":"https://haibeibei.github.io/blog/tags/javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://haibeibei.github.io/blog/tags/闭包/"}]},{"title":"css3动画","date":"2015-07-02T10:50:30.000Z","path":"2015/07/02/css3动画/","text":"触发方式单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可触发的方式有： :hoever :focus :checked 媒体查询触发 JavaScript触发 过渡的小结：transition的优点在于简单易用，但是它有几个很大的局限。transition需要事件触发，所以没法在网页加载时自动发生。transition是一次性的，不能重复发生，除非一再触发。 transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。一条transition规则，只能定义一个属性的变化，不能涉及多个属性。CSS Animation就是为了解决这些问题而提出的。 动画CSS3的animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。ainimation实现动画效果主要由两部分组成： 通过类似Flash动画中的帧来声明一个动画。在animation属性中调用关键帧声明的动画。注意：animation属性到目前位置得到了大多数浏览器的支持，但是，需要添加浏览器前缀！需要添加浏览器前缀！需要添加浏览器前缀！ animation-name：none为默认值，将没有任何动画效果，其可以用来覆盖任何动画animation-duration：默认值为0，意味着动画周期为0，也就是没有任何动画效果animation-timing-function：与transition-timing-function一样animation-delay：在开始执行动画时需要等待的时间animation-iteration-count：定义动画的播放次数，默认为1，如果为infinite，则无限次循环播放animation-direction：默认为nomal，每次循环都是向前播放，（0-100），另一个值为alternate，动画播放为偶数次则向前播放，如果为基数词就反方向播放animation-state：默认为running，播放，paused，暂停animation-fill-mode：定义动画开始之前和结束之后发生的操作，默认值为none，动画结束时回到动画没开始时的状态；forwards，动画结束后继续应用最后关键帧的位置，即保存在结束状态；backwards，让动画回到第一帧的状态；both：轮流应用forwards和backwards规则。animation属性类似于transition，他们都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"css3动画","slug":"css3动画","permalink":"https://haibeibei.github.io/blog/tags/css3动画/"}]},{"title":"Markdown语法 与 Hexo常用指令","date":"2015-06-30T16:22:10.000Z","path":"2015/07/01/Markdown语法 与 Hexo常用指令/","text":"Markdown语法 与 Hexo常用指令Markdown Hexo Markdown是一种超轻量级的标记语言，常用的标记符号不超过十个，相对于更为复杂的HTML标记语言来讲，Markdown实在简便多了，因此学习成本也不是很大。更多关于Markdown的认识，我们可以参考：认识与入门 Markdown。 常用语法常见格式及其对应的语法： Markdown 注释与示例: 粗体在字体两侧分别加两个星号 ** ， 当然，也能使用快捷键 Ctrl + B 快速加粗； 斜体将需要设置为斜体的文字两端使用一个 * （或者 _ ） 夹起来，快捷键 Ctrl + I ； 删除线在需要设置删除线的文字两侧加两个波浪线 ~~ 夹起来，可以表示删除文字； 分割线分割线的语法只需要三个星号*或者三个小短线 - 号，例如： 外链接描述 为文字添加外链接，可以使用快捷键 Ctrl + L 快速设置；示例： [HarbingWang的博客](http://harbingwang.github.io)显示： 这里是HarbingWang的博客 链接。 内嵌代码第一种:引入单行代码出现一个代码框，需要使用键盘左上角的ESC键下面的反单引号夹在文字两侧，两侧各一个就行。 例如：`Hellow world！` 显示：Hellow world！ 第二种：多行代码的引入需要在代码段的前后分别使用三个反单引号 显示： 1234for (int i = 0; i &lt; 100; i++)&#123; printf(&quot;hello markdown!\\n&quot;);&#125; 引入内容第一种:通过在文字开头添加“&gt;”表示块注释，快捷键使用 Ctrl + Q 例如； 如果你无法简洁的表达你的想法，那只说明你还不够了解它。 – 阿尔伯特·爱因斯坦 第二种: 使用tab键或者四个空格 12一个项目两部电脑三餐盒饭只为四千工资搞得五脏俱损六神无主仍然七点起床八点开会处理九个漏洞十分辛苦 十年编码九年加班八面无光忙的七窍生烟到头六亲不认五体投地依旧四肢酸软三更加班只为二个臭钱一生孤苦 插入图片插入图片的语法与插入链接很像，区别在一个插入图片的时候需要加一个!号 Markdown语法： 示例： Github 插入图片的地址需要图床生成图片外链，这里推荐使用七牛图床，生成URL地址即可。 不同Markdown工具下插入图片的方式也有所不同，这里只说明通用做法，具体可参考编辑器的使用说明； 分级标题标题是每篇文章中最常用的格式，在Markdown语法中，如果某行文字被定义为标题，只需要在行首加上#符号即可： 123456H1 : # Header 1H2 : ## Header 2H3 : ### Header 3H4 : #### Header 4H5 : ##### Header 5H6 : ###### Header 6 是几级标题就用几个 # 符号，每增加一个 # 表示更深入一个层次的内容，总共有六级标题。 标准的Markdown语法需要在符号后面多加一个空格，建议加上。 上面这种设置标题的方式是最为直观的，当然在Markdown语法下，我们也可以通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题，例如: 123456我是一级标题====我是二级标题---- 无序列表使用一个 *，+或- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 有序列表使用数字和英文句点表示有序列表, 不要求数字一定要连续。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 绘制表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 反斜杠Markdown 支持在以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 以上的Markdown语法基本上足够我们书写一篇博客了，关于Markdown的高级用法，包括通过Markdown创建公式，绘制流程图等请参考本文底部的 Reference相关； Hexo常用指令以下关于Hexo常用指令的整理，要想熟练使用一个工具，首先就要熟练掌握他的相关指令，以便操控这一工具。下面将着重介绍几条常用的 Hexo 指令： 1、新建文章1hexo new articleName Note： 新建一篇题为“articleName”的文章，此时会在E/Hexo/source/_posts/目录下生成一份articleName.md 的文件，使用Notepad++、小书匠、MarkdownPad2等编辑工具打开即能书写； 提示信息：INFO Created: E:\\Hexo\\source_posts[articleName.md](http://articlename.md/) 如果标题包含空格，需要使用双引号括起来 2、新建页面1hexo new page pageName Note： 新建一个题为“pageName”的页面，此时会在E:\\Hexo\\source\\目录下生成一个名为pageName的文件夹，其中包含一份 index 的md文件； 提示信息：INFO Created: E:\\Hexo\\source\\pageName[index.md](http://index.md/) 同样地，如果语句中包含空格，需要使用双引号括起来 3、生成静态页面1hexo generate Note： 启动该条指令后会将当前网页的内容生成静态页面到public目录下 提示信息：INFO Start processingINFO Files loaded in 595 msINFO 0 files generated in 612 ms 4、开启本地服务器端口1hexo server Note： 开启预览访问的端口，默认端口为4000 关闭server使用 ctrl + c 提示信息：INFO Start processingINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在使用hexo server 可能会遇到端口被占用的情况，不妨使用以下指令来更改端口 1hexo server -p 4001 5、部署到Github1hexo deploy Note： 将 E/Hexo/目录下的 .deploy_git 文件夹部署到Github 部署前需要预先 hexo generate 生成静态文件 关闭server使用 ctrl + c 提示信息：INFO Deploying: gitINFO Clearing .deploy_git folder…INFO Copying files from public folder……..部署的文件To git@github.com:HarbingWang/harbingwang.github.io.gitda818a3..e4e53c6 HEAD -&gt; masterINFO Deploy done: git # 当看到 “INFO Deploy done: git”时即表示部署已经完成； 6、清除文件1hexo clean Note： 清除E/Hexo目录下的缓存文件（db.json）和已经生成的静态文件（public）文件 网页正常情况下可以忽略此条命令 7、查看Hexo版本1hexo version Note： 查看当前使用的Hexo的版本号 提示信息：hexo: 3.2.0hexo-cli: 1.0.1os: Windows_NT 6.1.7601 win32 x64http_parser: 2.6.2node: 5.10.0v8: 4.6.85.31uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 47openssl: 1.0.2g 复合指令12hexo g -d hexo s -d Note： hexo g -d # 等价于 hexo generate –deploy ：生成静态文件并部署 hexo s -d # 等价于 hexo deploy –generate ：开启预览并部署到Github 简写形式12345hexo n #等价于 hexo newhexo g #等价于 hexo generatehexo s #等价于 hexo serverhexo d #等价于 hexo deployhexo v #等价于 hexo version 如何卸载Hexo？ 3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g ## 如何安装旧版本Hexo？ 先卸载当前版本，以2.8.3为例，执行npm install hexo@2.8.3 -g，再初始化并安装依赖和插件。","comments":true,"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://haibeibei.github.io/blog/tags/Markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://haibeibei.github.io/blog/tags/hexo/"}]},{"title":"正则表达式","date":"2015-06-01T06:40:45.000Z","path":"2015/06/01/正则表达式/","text":"\\d 匹配任意一个数字 [0-9] \\D 与除了数字以外的任何一个字符匹配 [^0-9] \\w 与任意一个英文字母,数字或下划线匹配 [a-z0-9A-Z_] \\W 除了字母,数字或下划线外与任何一个字符匹配 [^a-z0-9A-Z_] \\s 与任意一个空白字符匹配 [\\n\\f\\r\\t\\v] \\f 换页字符; \\n 换行字符; \\r 回车字符; \\t 制表符; \\v 垂直制表符; \\S 与除了空白符外任意一个字符匹配 [^\\n\\f\\r\\t\\v] [ ] 只匹配其中的一个原子 [^] 只匹配”除了”其中字符的任意一个原子 [0-9] 匹配0-9任何一个数字 [a-z] 匹配小写a-z任何一个字母 [A-Z] 匹配大写A-Z任何一个字母 在正则表达式中有一些特殊字符带表特殊意义叫元字符。 . 除换行符以外的任何一个字符 | 或的意思，匹配其中一项就代表匹配 例子:匹配身份证号，旧版是15位数字，新版是 18位数字 /^\\d{15} ¦\\d{18}$/","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://haibeibei.github.io/blog/tags/博客/"},{"name":"正则","slug":"正则","permalink":"https://haibeibei.github.io/blog/tags/正则/"}]}]